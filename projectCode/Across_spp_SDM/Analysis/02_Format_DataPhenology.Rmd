---
title: 'Formatting data'
author: "Lizbeth G Amador"
date: "2025-04-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Format data to fit into `biomod2` (includes spatial-temporal thinning and pivots).


# Presets 
```{r, warning=FALSE, message=FALSE}
# Load necessary libraries
#if statement to automatically install libraries if absent in r library
#tidyverse - mainly for data wrangling & plotting/mapping
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  install.packages("tidyverse")
}
library(tidyverse)

#terra - spatial package
if (!requireNamespace("terra", quietly = TRUE)) {
  install.packages("terra")
}
require(terra)

#sf - spatial package
if (!requireNamespace("sf", quietly = TRUE)) {
  install.packages("sf")
}
require(sf)

#BIEN - species range & occurrence 
if (!requireNamespace("BIEN", quietly = TRUE)) {
  install.packages("BIEN")
}
require(BIEN)

#tidyterra - spatial package for mapping
if (!requireNamespace("tidyterra", quietly = TRUE)) {
  install.packages("tidyterra")
}
require(tidyterra)

#biomod2 - ensemble modeling
# if (!requireNamespace("biomod2", quietly = TRUE)) {
#   install.packages("biomod2")
# }
# require(biomod2)
```

Directories 
```{r}
#ESIIL Macrophenology group - for saving 
main.dir = "G:/Shared drives/ESIIL_Macrophenology/Across_sp_SDM"
L2 = file.path(main.dir, "Data/L2")
```


# Phenology Data

Read in the data: 
```{r}
#Phenology 
load(file.path(L2, "phenology_timeperiods.RData"), verbose = TRUE)

#conus 
conus = vect(file.path(L2, "conus.shp"))
```

## Pivotting 

We want our dataset to be in wide format, were each column pertains to the species - including the lat/long information. We will also exclude any other columns. 

```{r}
#Historical
#excluding columns 
phe.h.long = phe.hist %>%
  dplyr::select(latitude, longitude, species, phenophase_status)
#pivot wider 
phe.h.wide = phe.h.long %>%
  pivot_wider(
  names_from = species, #column containing values to be converted to columns 
  values_from = phenophase_status, #cell values for the new columns
  values_fill = NA) 


#Current
#excluding columns 
phe.c.long = phe.cur %>%
  dplyr::select(latitude, longitude, species, phenophase_status)
#pivot wider 
phe.c.wide = phe.c.long %>%
  pivot_wider(
  names_from = species, #column containing values to be converted to columns 
  values_from = phenophase_status, #cell values for the new columns
  values_fill = NA) 

```



## Spatial/Temporal Thinning 
- Note: Need to thin data if spatial biases apparent (virtual group work)
```{r}

```


## Processing Data 
Coarsening sampling resolution - removing "repeated obs" for same locations 
```{r}
# Function to clean list-type species value
clean_species_list <- function(x) { #START of function 
  if (is.null(x) || all(is.na(x))) return(NA)

  # Flatten in case x is a list, convert to character
  x <- unlist(x)
  x <- as.character(x)
  
  # Split space-separated values and check for any '1'
  tokens <- unlist(strsplit(x, " "))
  if ("1" %in% tokens) { #START of if
    return(1)
  } else { #START of else
    return(0)
  } #END of else
} #END of Function

#Group species colmns 
species_cols <- c("Acer rubrum", "Juglans nigra", "Rubus laciniatus", 
                  "Ilex decidua", "Rubus spectabilis", "Acer platanoides")

#apply function to data frame
#historical 
phe.hw.clean <- phe.h.wide %>%
  mutate(across(all_of(species_cols), ~map(.x, clean_species_list))) %>%
  # Unlist the list-columns to flatten them to atomic columns
  mutate(across(all_of(species_cols), ~unlist(.x)))

#current
phe.cw.clean <- phe.c.wide %>%
  mutate(across(all_of(species_cols), ~map(.x, clean_species_list))) %>%
  # Unlist the list-columns to flatten them to atomic columns
  mutate(across(all_of(species_cols), ~unlist(.x)))
```


## Spatial Constraints 
```{r, message=FALSE, warning=FALSE}
# #to save in a specified directory 
# bien.range.out = "some/directory"
# BIEN_ranges_species(species = species_cols, directory = bien.range.out)

#to load into environment 
ranges = BIEN_ranges_load_species(species = species_cols)

# Disable S2
sf_use_s2(FALSE)
# Apply the zero-width buffer trick
ranges <- st_buffer(ranges, 0)
# Make geometries valid
ranges <- st_make_valid(ranges)
# Drop empty or still-invalid geometries
ranges <- ranges[!st_is_empty(ranges), ]
ranges <- ranges[st_is_valid(ranges), ]
# Optionally turn S2 back on for future operations
sf_use_s2(TRUE)


#change to terra object 
ranges.sh = vect(ranges)
#checking if CRS the same 
crs(ranges.sh) == crs(conus)
#if not use this 
# ranges.sh <- project(ranges.sh, #raster we want to reproject
#                                 crs(conus)) #reference raster


#ensure ranges are contained withint 
ranges.sh = intersect(ranges.sh, conus)

# terra uses standard subsetting
sp.range <- ranges.sh[ranges.sh$species == "Acer_rubrum", ]


plot(sp.range, main = paste(unique(sp.range$species)[1], "Range"), col = "grey")
plot(conus, add=TRUE)
```


Here is where we will filter for an individual species. We will also apply spatial contraints to observations based on their range from the BIEN package - **for now historical and current ranges will be the same** 
```{r}
#Historical 
#Filter for specific species 
df = phe.hw.clean %>% 
  select("longitude", "latitude", "Acer rubrum") %>% 
  #remove NAs that are based on other species presence 
  na.omit()
#convert into spatvector 
df = vect(df, geom = c("longitude", "latitude"), keep = TRUE, crs = crs(conus))
#plot
plot(conus, main = paste(names(df)[3], "Historical Observations"))
plot(sp.range, col="grey", add=TRUE)
plot(df, add=TRUE)

#drop any points outside of range shapefile 
df = intersect(df, sp.range)

#plotting
ggplot() + #base map
  geom_spatvector(data = sp.range, fill="grey") +
  #CONUS map layer
  geom_spatvector(data = conus, fill=NA, color='grey30')+ 
  #Points layer
  geom_spatvector(data = df, aes(color=as.factor(`Acer rubrum`))) + 
  #unique point value colors 
  scale_color_manual(values = c("0" = "#994455ff", "1" = "#044789ff"),
                     labels = c("Absent", "Present"),
                     name = "Acer rubrum") +
  ggtitle(paste(names(df)[3], "Historical Observations")) +
  theme_classic() + 
  theme(legend.position.inside = c(0.85, 0.2), 
        legend.background = element_rect(color = "black", linewidth = 0.5))

#revert back to a dataframe 
phe.hw = as.data.frame(df)

```

```{r}
#count unique values in column 
print("Historical sample sizes")
table(phe.hw$`Acer rubrum`)
```

```{r}
#Current 
#Filter for specific species 
df = phe.cw.clean %>% 
  select("longitude", "latitude", "Acer rubrum") %>% 
  #remove NAs that are based on other species presence 
  na.omit()
#convert into spatvector 
df = vect(df, geom = c("longitude", "latitude"), keep = TRUE, crs = crs(conus))
#plot
plot(conus, main = paste(names(df)[3], "Current Observations"))
plot(sp.range, col="grey", add=TRUE)
plot(df, add=TRUE)

#drop any points outside of range shapefile 
df = intersect(df, sp.range)

#plotting
ggplot() + #base map
  geom_spatvector(data = sp.range, fill="grey") +
  #CONUS map layer
  geom_spatvector(data = conus, fill=NA, color='grey30')+ 
  #Points layer
  geom_spatvector(data = df, aes(color=as.factor(`Acer rubrum`))) + 
  #unique point value colors 
  scale_color_manual(values = c("0" = "#994455ff", "1" = "#044789ff"),
                     labels = c("Absent", "Present"),
                     name = "Acer rubrum") +
  ggtitle(paste(names(df)[3], "Current Observations")) +
  theme_classic() + 
  theme(legend.position = c(0.85, 0.2), 
        legend.background = element_rect(color = "black", linewidth = 0.5))

#revert back to a dataframe 
phe.cw = as.data.frame(df)

```

```{r}
#count unique values in column 
print("Current sample sizes")
table(phe.cw$`Acer rubrum`)
```


 Save data 
```{r}
save(phe.hw, phe.cw, file= file.path(L2, "phenology_timeperiods_cleaned.RData"))
```
 




